{
	camera.kn:
		Last Modified: 2019/11/23 22:38:24.
		Created by Tatt(@tatt61880)
		https://twitter.com/tatt61880
		https://github.com/tatt61880

	3Dのカメラを動かすライブラリです。
}
+class Camera()
	var pos: Vector
	var dir: Vector
	var up: Vector
	
	+func init(x: float, y: float, z: float): @Camera
		do me.pos :: (#Vector).init(x, y, z)
		do me.dir :: (#Vector).init(0.0, 0.0, -1.0)
		do me.up :: (#Vector).init(0.0, 1.0, 0.0)
		ret me
	end func
	
	+func rotRel(horAngle: float, verAngle: float)
		do me.rotRelHor(horAngle)
		do me.rotRelVer(verAngle)
	end func
	
	+func rotRelHor(angle: float)
		{up周りの回転. 右ねじの回転が正}
		do me.dir.rot(me.up, angle)
		; do cui@print("[camera.kn] dir = " ~ me.dir.toStr())
	end func
	
	+func rotRelVer(angle: float)
		{dirとupの外積(cross). cross周りの回転. dirをup方向に回転させる向きが正}
		var cross: Vector :: me.dir.cross(me.up)
		do me.dir.rot(cross, angle)
		do me.up.rot(cross, angle)
		; do cui@print("[camera.kn] dir   = " ~ me.dir.toStr())
		; do cui@print("[camera.kn] up    = " ~ me.up.toStr())
		; do cui@print("[camera.kn] cross = " ~ cross.toStr())
	end func
	
	+func rotRelUp(angle: float)
		{upを回転．右ねじの回転が正}
		do me.up.rot(me.dir, angle)
	end func
	
	+func moveDir(d: float)
		do me.pos.x :+ me.dir.x * d
		do me.pos.y :+ me.dir.y * d
		do me.pos.z :+ me.dir.z * d
	end func
	
	+func moveRel(x: float, y: float, z: float)
		do me.pos.x :+ x
		do me.pos.y :+ y
		do me.pos.z :+ z
	end func
	
	+func moveAbs(x: float, y: float, z: float)
		do me.pos.x :: x
		do me.pos.y :: y
		do me.pos.z :: z
	end func
	
	+func setCamera()
		do draw@camera(me.pos.x, me.pos.y, me.pos.z, (me.pos.x + me.dir.x), (me.pos.y + me.dir.y), (me.pos.z + me.dir.z), me.up.x, me.up.y, me.up.z)
	end func
	
	class Vector()
		+var x: float
		+var y: float
		+var z: float
		
		+func init(x: float, y: float, z: float): Vector
			do me.x :: x
			do me.y :: y
			do me.z :: z
			ret me
		end func
		
		+func rot(axis: Vector, angle: float)
			var cos: float :: lib@cos(angle)
			var sin: float :: lib@sin(angle)
			var d: Vector :: ##me
			do me.x :: (axis.x * axis.x * (1.0 - cos) + cos) * d.x + (axis.x * axis.y * (1.0 - cos) - axis.z * sin) * d.y + (axis.z * axis.x * (1.0 - cos) + axis.y * sin) * d.z
			do me.y :: (axis.x * axis.y * (1.0 - cos) + axis.z * sin) * d.x + (axis.y * axis.y * (1.0 - cos) + cos) * d.y + (axis.y * axis.z * (1.0 - cos) - axis.x * sin) * d.z
			do me.z :: (axis.z * axis.x * (1.0 - cos) - axis.y * sin) * d.x + (axis.y * axis.z * (1.0 - cos) + axis.x * sin) * d.y + (axis.z * axis.z * (1.0 - cos) + cos) * d.z
		end func
		
		+func cross(t: Vector): Vector
			ret (#Vector).init(me.y * t.z - me.z * t.y, me.z * t.x - me.x * t.z, me.x * t.y - me.y * t.x)
		end func

		+*func toStr(): []char
			ret "(" ~ me.x.toStr() ~ ", " ~ me.y.toStr() ~ ", " ~ me.z.toStr() ~ ")"
		end func
	end class
end class
